<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Original Paradigm</title>
  
  <subtitle>Technical thinking</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.oripd.com/"/>
  <updated>2020-12-17T07:08:33.999Z</updated>
  <id>http://blog.oripd.com/</id>
  
  <author>
    <name>AmadeusQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习新编程语言的套路</title>
    <link href="http://blog.oripd.com/2016/12/05/learning-new-program-language/"/>
    <id>http://blog.oripd.com/2016/12/05/learning-new-program-language/</id>
    <published>2016-12-05T04:20:36.000Z</published>
    <updated>2020-12-17T07:08:33.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语言应用层面"><a href="#语言应用层面" class="headerlink" title="语言应用层面"></a>语言应用层面</h1><ol><li>基本数据类型</li><li>类型系统</li><li>运算符</li><li>函数，方法，接口，包</li><li>编程范式</li><li>控制语句</li><li>数据结构及表示</li><li>并发模型</li><li>异常处理</li><li>文件处理</li><li>内置函数与基本库</li><li>构建工具</li><li>其他具有独自特点的语言特性</li></ol><h1 id="语言原理层面"><a href="#语言原理层面" class="headerlink" title="语言原理层面"></a>语言原理层面</h1><ol><li>GC</li><li>编译/解释</li><li>在相同编程范式语言中的地位</li><li>语言特性的实现思路与模式</li><li>Runtime</li></ol><h1 id="工程应用层面"><a href="#工程应用层面" class="headerlink" title="工程应用层面"></a>工程应用层面</h1><ol><li>应用领域</li><li>成熟的应用框架</li><li>编程语言的生态（包含常用的库）</li><li>编码规范</li><li>工程代码组织</li><li>部署及监控</li></ol>]]></content>
    
    <summary type="html">
    
      简要总结学习一门新的编程语言需要注意的点
    
    </summary>
    
      <category term="technology" scheme="http://blog.oripd.com/categories/technology/"/>
    
    
      <category term="new languages" scheme="http://blog.oripd.com/tags/new-languages/"/>
    
  </entry>
  
  <entry>
    <title>Resources about distributed file system</title>
    <link href="http://blog.oripd.com/2016/05/09/DFS/"/>
    <id>http://blog.oripd.com/2016/05/09/DFS/</id>
    <published>2016-05-09T08:36:01.000Z</published>
    <updated>2020-12-17T07:07:54.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h1><ul><li><a href="https://en.wikipedia.org/wiki/Clustered_file_system" target="_blank" rel="noopener">Clustered file system</a></li><li><a href="https://en.wikipedia.org/wiki/Category:Distributed_file_systems" target="_blank" rel="noopener">Category: Distributed file system</a></li><li><a href="https://en.wikipedia.org/wiki/Distributed_File_System_(Microsoft)" target="_blank" rel="noopener">Distributed file system (Microsoft)</a></li><li><a href="https://technet.microsoft.com/en-us/library/cc786269(v=ws.10).aspx" target="_blank" rel="noopener">Distributed file system - TechNet</a></li><li><a href="https://msdn.microsoft.com/en-us/library/bb524800(v=vs.85).aspx" target="_blank" rel="noopener">Distributed file system - MSDN</a></li></ul><h1 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h1><ul><li><a href="http://www.amazon.com/NFS-Illustrated-Brent-Callaghan/dp/0201325705/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1280976566&amp;sr=1-1" target="_blank" rel="noopener">NFS Illustrated 1st Edition</a></li></ul><h1 id="Papers-amp-Conferences"><a href="#Papers-amp-Conferences" class="headerlink" title="Papers &amp; Conferences"></a>Papers &amp; Conferences</h1><ul><li><a href="https://www.usenix.org/legacy/events/fast11/" target="_blank" rel="noopener">FAST (Usenix Conference on File and Storage Technologies) </a></li><li><a href="http://www.cs.cmu.edu/~garth/#research" target="_blank" rel="noopener">The collected works of Garth Gibson</a></li><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.71.5072&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Scale and Performance in a Distributed Filesystem</a></li><li><a href="http://dl.acm.org/citation.cfm?id=195481" target="_blank" rel="noopener">Separating data and control transfer in distributed operating systems</a></li><li><a href="http://www.eecs.berkeley.edu/Research/Projects/CS/sprite/sprite.papers.html" target="_blank" rel="noopener">Zebra</a></li><li>Design and Implementation of the Sun Network Filesystem</li><li>Disconnected Operation in the Coda Filesystem</li><li>The Google File System</li><li><a href="https://pdos.csail.mit.edu/6.824/papers/thekkath-frangipani.pdf" target="_blank" rel="noopener">Frangipani: A Scalable Distributed Filesystem</a></li><li><a href="http://ceph.com/papers/weil-ceph-osdi06.pdf" target="_blank" rel="noopener">CEPH: A Scalable, High-performance Distributed Filesystem</a></li></ul><h1 id="Courses"><a href="#Courses" class="headerlink" title="Courses"></a>Courses</h1><ul><li><a href="https://pdos.csail.mit.edu/archive/6.824-2007/labs/index.html" target="_blank" rel="noopener">The 6.824 (Distributed Systems Course at MIT) </a></li></ul><h1 id="Open-Source-Projects"><a href="#Open-Source-Projects" class="headerlink" title="Open Source Projects"></a>Open Source Projects</h1><ul><li>IPFS</li><li>LizardFS</li><li>GlusterFS</li><li>Lustre</li><li>PVFS</li><li>Ceph</li><li>HDFS</li><li>MogileFS</li></ul><h1 id="Other-material"><a href="#Other-material" class="headerlink" title="Other material"></a>Other material</h1><ul><li><a href="https://www.quora.com/What-is-the-future-of-file-system(https://www.quora.com/What-is-the-future-of-file-systemss" target="_blank" rel="noopener">What is the future of file systems? - Quora</a></li></ul>]]></content>
    
    <summary type="html">
    
      A collection of resources about distributed file system
    
    </summary>
    
      <category term="technology" scheme="http://blog.oripd.com/categories/technology/"/>
    
    
      <category term="DFS" scheme="http://blog.oripd.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>高效阅读源代码指南</title>
    <link href="http://blog.oripd.com/2016/04/28/how-to-read-open-project/"/>
    <id>http://blog.oripd.com/2016/04/28/how-to-read-open-project/</id>
    <published>2016-04-28T06:09:17.000Z</published>
    <updated>2020-12-17T07:08:26.538Z</updated>
    
    <content type="html"><![CDATA[<p>最近一年里，我阅读了不少开源项目的源代码，之前也和朋友讨论过阅读源代码时遇到的一些问题。我觉得有必要写一篇博文分享一下自己的经验。</p><h1 id="序章：准备工作"><a href="#序章：准备工作" class="headerlink" title="序章：准备工作"></a>序章：准备工作</h1><p>通常情况下，我们不会无缘无故拿到一份源代码，我是说，当想要阅读源代码时，一定是抱着某种目的进行下去的，这个<strong>目的</strong>会贯穿整个研究过程，比如：</p><ul><li>想研究某个东西的实现</li><li>想学习作者的代码风格和项目组织</li><li>想参考实现并用其他语言移植项目</li></ul><p>等等。所以在最初的时候，明确自己阅读源代码的目的非常关键。</p><p>在明确了目的之后，就可以正式开始深挖代码了。不过在此之前，还是要提醒一下：工欲善其事，必先利其器。</p><p>可以用来写代码的工具有很多，如包括Vim、Emacs、SublimeText、Atom等在内的Text Editor，还有包括Visual Studio和JetBrains全家桶在内的IDE。Text Editor在编写代码时有无与伦比的优势，方便的快捷键、一流的反省速度、高度可配置的编辑环境等等，无疑能极大程度上提高程序员的手速，然而这些亮点都不是在阅读代码时候所必须的；阅读代码时，很多时候需要搞清楚函数之间的调用关系，这时候就需要有强大的代码静态分析工具和一个便捷的断点调试工具，这也正是IDE的优势。</p><p>因此我郑重推荐在阅读代码时使用IDE，当然如果是较小的项目加之已经调教成IDE的Vim/Emacs，也是没什么问题的。</p><p>接下来，就真的可以开始深挖代码了。</p><h1 id="第一步：自顶向下理清代码组织关系"><a href="#第一步：自顶向下理清代码组织关系" class="headerlink" title="第一步：自顶向下理清代码组织关系"></a>第一步：自顶向下理清代码组织关系</h1><h2 id="代码组织结构"><a href="#代码组织结构" class="headerlink" title="代码组织结构"></a>代码组织结构</h2><p>很多时候这一点根本就不是问题，因为项目的构建无非是通过构建工具、框架或最佳实践来做的，实在不行还可以查阅开发文档。</p><h2 id="Code-Breakdown-Structure"><a href="#Code-Breakdown-Structure" class="headerlink" title="Code Breakdown Structure"></a>Code Breakdown Structure</h2><p>这是我认为最重要的一个步骤，然而我也吃惊地发现，并不是每个人都能重视这个步骤并处理得很好。</p><p>所谓Code Breakdown Structure的说法，本身源自软件工程中Work Breakdown Structure。WBS把软件需求按照业务的角度逐级下分，而这份产物能够直接影响到项目代码里的数据模型。</p><p>当然，项目代码里的结构，不仅仅受到了实际需求的影响，也受到了构建工具和设计模式的影响，比如能够应用在全局的MVC模式，或者应用在局部场景的单例模式、状态模式等等，更会受到程序语言相关层面的直接影响；但不论是怎样的软件模式、怎样的编程范式，阅读源代码时仍旧需要搞清楚不同的代码组织在整个项目里的角色是什么，需要分别知道数据层、工具函数、顶层抽象、抽象实现和具体的功能性代码分别是什么、在哪里。在整理这部分内容的时候，通常会在脑海中形成清晰的思路，但如果可以的话，请把这些东西用纸笔画出来。</p><p>如果想要研究的是具体的功能实现，就需要在上面的基础上更进一步，着眼于功能性的代码，对每个功能实现画出活动图和时序图。</p><p>总之这一步里包含了不小的工作量，但搞清楚这些东西，是继续进行下去的基础。</p><h1 id="第二步：有针对性地深挖代码"><a href="#第二步：有针对性地深挖代码" class="headerlink" title="第二步：有针对性地深挖代码"></a>第二步：有针对性地深挖代码</h1><p>这是阅读代码的核心步骤，是最复杂的一个步骤，也是我无法在此篇文章中展开的步骤。因为每个人阅读代码的目的不尽相同，每个人研究问题的习惯也有很大差异。</p><p>研究问题的时候，通常会有大量自己改代码、打断点、做编译的机会，请尽情享受解决自己目标问题的思维过程，并且不要忘记以下重要的辅助资源：</p><ul><li>开发文档</li><li>开发日志（Issues, Mails）</li><li>主要开发成员的博客（如果有的话）</li><li>相关领域的资料，包括书籍和论文</li><li>与同类开源项目产品的实现相比较</li><li>与原作者、开发组进行沟通：IRC、Maillist、Gitter等</li></ul><h1 id="第三步：自底向上理解局部代码在全局中的重要性"><a href="#第三步：自底向上理解局部代码在全局中的重要性" class="headerlink" title="第三步：自底向上理解局部代码在全局中的重要性"></a>第三步：自底向上理解局部代码在全局中的重要性</h1><p>不论是把眼光聚焦在对问题的解决方案上，还是在代码组织、设计模式上，能针对结果做进一步抽象，才是最好的。</p><p>这里面蕴含的机会是：</p><ul><li>一旦理解了作者的解决方法，对自己理解这种解决方案本身和背后的业务模型都有提升。</li><li>一旦发现了更好的解决方案，自己就有机会提PR。</li></ul><p>尽管要做好这一步，需要较强的领域技术背景，但如果能坚持尝试这么做的话，会受益匪浅。</p><h1 id="接下来的事情"><a href="#接下来的事情" class="headerlink" title="接下来的事情"></a>接下来的事情</h1><p>阅读完一份源代码，找到了自己需要的东西，让自己的能力得到提升。接下来的事情当然是：</p><ul><li>多运动，让自己大脑放松一下</li><li>多陪陪父母妻儿(没有妹子的话就去找)</li><li>阅读下一份开源代码</li></ul><p>（完）</p>]]></content>
    
    <summary type="html">
    
      这是一篇很短的文章，不仅适用于开源项目，也适用于接手别人的项目代码。
    
    </summary>
    
      <category term="technology" scheme="http://blog.oripd.com/categories/technology/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04 安装小记</title>
    <link href="http://blog.oripd.com/2016/04/24/ubuntu1604-installation/"/>
    <id>http://blog.oripd.com/2016/04/24/ubuntu1604-installation/</id>
    <published>2016-04-24T04:17:30.000Z</published>
    <updated>2020-12-17T07:08:45.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Ubuntu大概是最容易安装的一个Linux发行版，因此本文并不是普通意义上的安装教程或新品尝鲜的感受。</p><p>本文针对的读者，是那些想在有双显卡（Intel和NVIDIA）的笔记本上安装Ubuntu 16.04的人，以及对我的电脑有浓厚好奇心的观众。</p><h1 id="我的电脑"><a href="#我的电脑" class="headerlink" title="我的电脑"></a>我的电脑</h1><p>因为兴趣爱好和使用习惯上的偏好，我在去年年底购入了一台未来人游戏本，打算由此替换掉使用了两年多的Macbook Air，并彻底抛弃Mac平台。</p><p>这台未来人的主要配置如下：</p><ul><li>CPU: Intel i7 6700HQ</li><li>GPU:<ul><li>Intel HD 530</li><li>NVIDIA GTX 970M</li></ul></li><li>Network Controller: Intel Corporation Wireless 3165</li></ul><p>这些硬件配置意味着对系统的特殊要求：</p><ul><li>内核版本在4.2以上才能保证无线网卡的正常工作。</li><li>内核版本在4.4以上才能完全支持SkyLake系列CPU。</li><li>需要安装闭源驱动才能让独立显卡发挥出最高性能，同时支持双显卡切换。</li></ul><h1 id="为什么选择Ubuntu"><a href="#为什么选择Ubuntu" class="headerlink" title="为什么选择Ubuntu"></a>为什么选择Ubuntu</h1><p>从去年购入电脑之后，因为硬件太新的原因，我不断尝试安装各种不同的发行版，但无一成功，这其中包括：</p><ul><li>Arch Linux: 我在这台电脑上安装Arch的时候，Kernel 4.4 还没发布，同时由于电脑上其他硬件以及我不信奉Arch哲学的原因，我没有对Arch做更多的尝试。</li><li>Gentoo Linux: 我是Gentoo的死忠，这次尝试过Gentoo之后发现，双显卡的设置令我捉摸不透，因此Gentoo暂时搁置。</li><li>Redhat系：由于Nouveau的原因，导致安装程序无法正常启动，放弃。</li><li>Debian：同上。</li><li>Ubuntu：尝试过各种版本号，其中大部分会因Nouveau的问题而挂掉，15.10 和16.04 可以安装上，安装完成后需要手动配置其他东西（内核版本、内核模块、闭源驱动等）；最终我选择了16.04。</li></ul><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>Ubuntu 16.04 的安装过程一如既往地“无痛”。只是，在我这台电脑上安装完成后，无法直接进入系统（因为会死机）。</p><h1 id="后续处理"><a href="#后续处理" class="headerlink" title="后续处理"></a>后续处理</h1><p>因为Ubuntu 16.04 提供了4.4.0的内核，所以不需要再进行任何方式的内核升级，但因为要处理显卡驱动，所以还要简单处理一下内核模块。</p><h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h2><p>该发行版依旧内置了Nouveau 开源驱动，这是导致频繁死机的直接原因。接下来要做的三件事情是：</p><ul><li>禁用Nouveau 内核模块</li><li>安装Intel HD 530 驱动（二选一）</li><li>安装NVIDIA 闭源驱动（二选一）</li></ul><h3 id="禁用Nouveau-内核模块"><a href="#禁用Nouveau-内核模块" class="headerlink" title="禁用Nouveau 内核模块"></a>禁用Nouveau 内核模块</h3><p>首先添加一个blacklist:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/modprobe.d/blacklist-nouveau.conf</span></span><br></pre></td></tr></table></figure><p>在这个文件中写入以下内容：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">blacklist </span>nouveau</span><br><span class="line"><span class="keyword">blacklist </span><span class="keyword">lbm-nouveau</span></span><br><span class="line"><span class="keyword">options </span>nouveau modeset=<span class="number">0</span></span><br><span class="line">alias nouveau off</span><br><span class="line">alias <span class="keyword">lbm-nouveau </span>off</span><br></pre></td></tr></table></figure><p>为了保证完全禁用掉，还要在内核中直接禁用Nouveau:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> options nouveau modeset=0 | sudo tee -a /etc/modprobe.d/nouveau-kms.conf</span></span><br></pre></td></tr></table></figure><p>这之后，更新配置试生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> update-initramfs -u</span></span><br></pre></td></tr></table></figure><p>重启后再次进入系统，就能避免登录之后直接卡死的情况。</p><h3 id="安装Intel-HD-530-驱动"><a href="#安装Intel-HD-530-驱动" class="headerlink" title="安装Intel HD 530 驱动"></a>安装Intel HD 530 驱动</h3><p>在进行完以上操作后，可以登录进系统，但卡死的情况仍然频繁发生。解决方案要么是安装Intel的驱动，要么是安装NVIDIA的闭源驱动，可以根据自己的需求来决定。</p><p>要安装的是Guc Firmware for SkyLake，可以来<a href="https://01.org/zh/linuxgraphics/downloads/skylake-guc-6.1" target="_blank" rel="noopener">这里</a>下载。</p><p>下载后，解压、安装、重启，电脑即可正常运行。如果不想安装NVIDIA闭源驱动的话，就可以到此结束了。</p><p>然而在我的电脑上，只安装Intel驱动会遗留一个Bug：无法支持外接显示器。</p><h3 id="安装NVIDIA闭源驱动"><a href="#安装NVIDIA闭源驱动" class="headerlink" title="安装NVIDIA闭源驱动"></a>安装NVIDIA闭源驱动</h3><p>网上有非常多种安装N卡驱动的方法，根据我的实验，只有最简单的是最靠谱的；用其他方法安装会出现各种意外。</p><p>首先打开Ubuntu 自带的Additional Drivers:</p><p><img src="menu.png" alt></p><p>在Additional Drivers标签可以看到，系统已经识别出具体的N卡型号，并给出了闭源驱动的版本号：</p><p><img src="additional_driver.png" alt></p><p>在Terminal 中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install nvidia-[version]    <span class="comment"># version为具体的版本号，如图所示为'361'</span></span></span><br></pre></td></tr></table></figure><p>安装完毕后，再在Additional Drivers里选择该驱动，重启即可正常使用。</p><p><img src="prime.png" alt></p><p>可以看到，在NVIDIA Settings里，可以进行双显卡切换，不过切换后需要注销并重新登录才能应用设置。</p><p>这里有个尚未解决的Bug：在安装了N卡闭源驱动之后，如果在PRIME中选择应用Intel显卡，会出现无法正常关机的情况。因此一旦安装了N卡驱动，就一直使用N卡驱动吧。</p><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>我这里安装的是搜狗拼音，分三步：</p><ol><li>从官网上下载了deb并安装时，会遇到依赖缺失的情况，用<code>apt-get install -f</code>解决。</li><li>进入系统设置的语言设置时，会提示语言未安装完全，此处要根据提示进行安装。</li><li>安装之后，在语言设置里设置使用Fcitx，在Fcitx设置的Input Method选显卡中记得添加Sogou Pinyin，这时搜狗拼音输入法才会在顶部显示出来。</li></ol><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>关于安装，到此告一段落。</p><p>然而经理了这么长时间的折腾，我对此还是有些感慨的：</p><ol><li>不要购买太新的电脑用来跑Linux。</li><li>对于驱动软件，我认为闭源驱动比开源驱动更值得信赖。</li><li>作为一名Linux用户，应该定期查阅Kernel Mailing List。</li></ol>]]></content>
    
    <summary type="html">
    
      这台天湖笔记本终于折腾好了
    
    </summary>
    
      <category term="technology" scheme="http://blog.oripd.com/categories/technology/"/>
    
    
      <category term="Linux" scheme="http://blog.oripd.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>UX Designer</title>
    <link href="http://blog.oripd.com/2014/05/27/ux-designer/"/>
    <id>http://blog.oripd.com/2014/05/27/ux-designer/</id>
    <published>2014-05-26T16:00:00.000Z</published>
    <updated>2020-12-17T07:08:56.358Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>感谢@WingWxy的热心指导。</p></blockquote><p>在Web设计的实际流程中，处在设计这个工作线的人的职务主要有：</p><ul><li>用户研究</li><li>用户体验师</li><li>交互设计师</li><li>视觉设计师</li></ul><p>一般来说，学美术的童鞋在这些工作流程中主要承担的职位是<strong>交互设计师</strong>和<strong>视觉设计师</strong>，以下按照这两个职务来分类说说一个大致的学习流程。</p><h3 id="交互设计师"><a href="#交互设计师" class="headerlink" title="交互设计师"></a>交互设计师</h3><p>需要的知识储备：</p><ul><li>前端基础知识，了解HTML和CSS。</li><li>熟悉那些特效可以用HTML5和CSS3实现。</li><li>网页设计的大致原则（如表单设计，按钮设计，窗口切换设计等）</li><li>快速原型的设计工具的使用。</li><li>用户体验的一些基本原则（Don’t make me think）</li></ul><p>建议的学习流程：</p><ul><li>熟悉W3School网站，学些查阅W3School的资料。</li><li>熟悉HTML5和CSS3特性（表现效果方面）</li><li>了解响应式设计</li><li>了解以前两种前端框架（主要是框架的长相、交互风格）</li><li>看一些交互设计原则的书</li><li><strong>表单设计和窗口切换</strong>是重点</li><li>学习一两种原型绘制的工具，如Pencil等。</li><li>（*可选）学会写规范的交互文档</li></ul><h3 id="视觉设计师"><a href="#视觉设计师" class="headerlink" title="视觉设计师"></a>视觉设计师</h3><p>需要的知识储备：</p><ul><li>熟练使用PS（至少图片分层批量导出以及路径工具要熟）</li><li>看得懂交互设计师的原型图和交互文档</li><li>色彩和布局的相关知识</li><li>了解图标设计、按钮设计的工具和网站</li><li>大量收集素材（如网页底纹、按钮、图标的源文件等）</li><li>（<em>如果是移动设计师</em>）熟悉Android和iOS的设计文档，背得出各种元素的分辨率。</li></ul><h3 id="一些工具-网站推荐"><a href="#一些工具-网站推荐" class="headerlink" title="一些工具/网站推荐"></a>一些工具/网站推荐</h3><ul><li><p><a href="http://livetools.uiparade.com" target="_blank" rel="noopener">Live Tools</a>是一个超棒的在线工具箱，帮助你在线设计不同的Web UI元素，包括：</p><ul><li>按钮制作</li><li>表单制作</li><li>title 图标制作</li><li>彩带制作</li></ul></li></ul><p>你可以免费自由下载生成的CSS3代码，并免费使用到你的在线应用或网站中。</p><ul><li><a href="http://ringmark.io" target="_blank" rel="noopener">ringmark.io</a>是一个动态监测浏览器对HTML支持成都的工具，它将测试你当前的浏览器，将HTML5规格当中描述的功能的实现程度一一测试出来。</li><li><a href="http://www.creativebloq.com/web-design/training-online-resources-812225" target="_blank" rel="noopener">二十个在线工具推荐</a></li></ul>]]></content>
    
    <summary type="html">
    
      根据邮件整理的UE/UX指南
    
    </summary>
    
      <category term="technology" scheme="http://blog.oripd.com/categories/technology/"/>
    
    
      <category term="design" scheme="http://blog.oripd.com/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>Git入门指引</title>
    <link href="http://blog.oripd.com/2014/05/21/GitBeginning/"/>
    <id>http://blog.oripd.com/2014/05/21/GitBeginning/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2021-10-09T07:47:36.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文面向<strong>初次</strong>接触版本控制系统的Git用户，旨在介绍一些关于版本控制和Git的简单概念。</p><p>文中并不涉及过多的Git实际操作，文末推荐更多的Git学习资源。</p></blockquote><h3 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h3><p>Git是目前最先进的版本控制系统，拥有最多的用户数量并管理着数量庞大的实际软件项目；风靡全球的Github更是让Git版本控制系统名声大震。本文以“版本控制系统”为切入点，以Gitlab平台为例，介绍相关概念和简单的Git用法。</p><h3 id="什么是版本控制系统？"><a href="#什么是版本控制系统？" class="headerlink" title="什么是版本控制系统？"></a>什么是版本控制系统？</h3><p>如果对“版本控制”没有概念，那真是没法用Git。</p><p>所以我们来看一个例子：假设大四毕业生小张在写毕业论文，写好初稿后经常删改，甚至还会在第二天把前一天删掉的东西找回来。如果他动点脑子，就不会只在一个文档中改来改去，而会在文件夹中有：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">毕业论文<span class="number">_</span>初稿.<span class="meta">doc</span></span><br><span class="line">毕业论文<span class="number">_</span>修改<span class="number">1</span>.<span class="meta">doc</span></span><br><span class="line">毕业论文<span class="number">_</span>修改<span class="number">2</span>.<span class="meta">doc</span></span><br><span class="line">毕业论文<span class="number">_</span>修改<span class="number">3</span>.<span class="meta">doc</span></span><br><span class="line">毕业论文<span class="number">_</span>完整版<span class="number">1</span>.<span class="meta">doc</span></span><br><span class="line">毕业论文<span class="number">_</span>完整版<span class="number">2</span>.<span class="meta">doc</span></span><br><span class="line">毕业论文<span class="number">_</span>完整版<span class="number">3</span>.<span class="meta">doc</span></span><br><span class="line">毕业论文<span class="number">_</span>最终版<span class="number">1</span>.<span class="meta">doc</span></span><br><span class="line">毕业论文<span class="number">_</span>最终版<span class="number">2</span>.<span class="meta">doc</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>看起来是不是很郁闷啊？小张当然也郁闷了，因为自己总是改不好，所以他把自己的论文发给朋友（是学霸），求帮忙；与此同时他自己也在继续修改。第二天就有了：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">毕业论文<span class="number">_</span>最终版<span class="number">3</span>.<span class="meta">doc</span></span><br><span class="line">毕业论文<span class="number">_</span>学霸版<span class="number">1</span>.<span class="meta">doc</span></span><br></pre></td></tr></table></figure><p>他朋友毕竟是学霸，当然给他的论文做了比较大的修改，此时小张虽然看到了希望，但还要纠结着做一件事情：把上面两个版本的论文合并成：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">毕业论文<span class="number">_</span>死也不改版.<span class="meta">doc</span></span><br></pre></td></tr></table></figure><p>等合并好，已是凌晨三点半。小张无比怨念！</p><p><strong>怎么办？</strong></p><p>小张想，如果能有个什么东西来帮忙控制一下这该死的版本，那真是谢天谢地了！就像这样：</p><table><thead><tr><th>版本</th><th style="text-align:left">修改人</th><th style="text-align:left">说明</th><th style="text-align:left">日期</th></tr></thead><tbody><tr><td>初稿</td><td style="text-align:left">小张</td><td style="text-align:left">这是初稿</td><td style="text-align:left">Day1</td></tr><tr><td>修改1</td><td style="text-align:left">小张</td><td style="text-align:left">修改目录</td><td style="text-align:left">Day2</td></tr><tr><td>修改2</td><td style="text-align:left">小张</td><td style="text-align:left">合并段落</td><td style="text-align:left">Day3</td></tr><tr><td>……</td><td style="text-align:left">……</td><td style="text-align:left">……</td><td style="text-align:left">……</td></tr><tr><td>最终版2</td><td style="text-align:left">小张</td><td style="text-align:left">xxx</td><td style="text-align:left">Day7</td></tr><tr><td>死也不改版</td><td style="text-align:left">学霸</td><td style="text-align:left">bala</td><td style="text-align:left">Day8</td></tr></tbody></table><p>这样就不用手动控制那么多版本啦！</p><p><strong>所以，所谓“版本控制系统”，就是来解决这类问题的。</strong></p><h3 id="Git又是什么？"><a href="#Git又是什么？" class="headerlink" title="Git又是什么？"></a>Git又是什么？</h3><p>没错，Git就是一个版本控制软件。在进行软件开发时，一个团队的人靠使用Git，就能轻松管理好项目版本，做好项目的追踪和辅助进度控制。确切的讲，Git是一款分布式版本控制系统。这个“分布式”，要和“集中式”放在一起理解。</p><p>所谓“集中式版本控制”，就好比这一个团队中，<strong>版本库</strong>都集中在一台服务器上，每个开发者都要从服务器上获取最新的版本库后才能进行开发，开发完了再把新的版本提交回去。</p><p>而“分布式版本控制”，则是这个团队中每个人的电脑上都会有一份完整的<strong>版本库</strong>，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p><p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p><h3 id="版本库是咋回事？"><a href="#版本库是咋回事？" class="headerlink" title="版本库是咋回事？"></a>版本库是咋回事？</h3><p>版本，不是文件的版本么？这个版本库是什么意思？</p><p>如果能意识到控制的是文件的版本，那就离理解版本库只差一步了（最关键的一步）。</p><p>程序要记录项目的版本号，最简单的方法就是把版本相关的信息放在某文件里，持续写入文件便视为版本更新。所以，当我们在一个目录中运行命令：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git init</span><br><span class="line"><span class="comment"># Git初始化的命令，用于新建版本库</span></span><br></pre></td></tr></table></figure><p>这个目录中就会默认产生一个新目录：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.git/</span></span><br></pre></td></tr></table></figure><p>没错，这就是我们刚刚新建的版本库，它将默认记录当前目录（直接包含<code>.git</code>的这个目录，下文中叫做“项目目录”）中任何文件的改动。如果把这个版本库删除了，这里面记录的文件版本就都没有了，项目目录中的文件当前是什么样子，那就一直是什么样子，没法恢复到以前的版本了。如果想让Git忽视项目目录中的什么文件（比如程序缓存等），可以在<code>.gitignore</code>中写清楚那些文件。</p><p>而Git所记录的文件“版本”，是长这个样子的，运行<code>git log</code>命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span> <span class="number">3</span>a3b317144517fd95f4e3d1ffc27a9460242abc (<span class="keyword">HEAD</span> -&gt; <span class="keyword">master</span>, origin/<span class="keyword">master</span>, origin/<span class="keyword">HEAD</span>)</span><br><span class="line">Author: JohnDoe &lt;john.doe@foobar.com&gt;</span><br><span class="line"><span class="built_in">Date</span>:   Sat <span class="keyword">Oct</span> <span class="number">9</span> <span class="number">15</span>:<span class="number">33</span>:<span class="number">37</span> <span class="number">2021</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> <span class="number">929</span>cc40e8a6ef5d6449387801ad06cb5a15c0abc</span><br><span class="line">Author: JohnDoe &lt;john.doe@foobar.com&gt;</span><br><span class="line"><span class="built_in">Date</span>:   Fri <span class="built_in">Dec</span> <span class="number">18</span> <span class="number">11</span>:<span class="number">41</span>:<span class="number">00</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> <span class="keyword">share</span> helper</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> <span class="number">03</span>f15d17ab7523128d92efb5c02770f68a094abc</span><br><span class="line">Author: JohnDoe &lt;john.doe@foobar.com&gt;</span><br><span class="line"><span class="built_in">Date</span>:   Thu <span class="built_in">Dec</span> <span class="number">17</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">04</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> favicon <span class="keyword">as</span> website ico <span class="keyword">of</span> title</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> <span class="number">0836292</span>ec6623aa0cb15c933e39f0210994b9abc</span><br><span class="line">Author: JohnDoe &lt;john.doe@foobar.com&gt;</span><br><span class="line"><span class="built_in">Date</span>:   Thu <span class="built_in">Dec</span> <span class="number">17</span> <span class="number">15</span>:<span class="number">16</span>:<span class="number">00</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    adjust categories</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里面<code>commit</code>后面跟随的一长串MD5值，就是Git所记录的每一次改动的文件版本。</p><h3 id="那么，Git怎么用？"><a href="#那么，Git怎么用？" class="headerlink" title="那么，Git怎么用？"></a>那么，Git怎么用？</h3><p>在实际应用中，Git有非常多的用法，而本文是面向Git完全初学者，所以我们要从最基本的开始做。<br>比如，在刚才建好的版本库中，A新建了README文件，并在里面写了东西。写好后他想给项目做个版本，就需要这样：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> README</span></span><br><span class="line">$ git commit -m <span class="string">"add README"</span></span><br></pre></td></tr></table></figure><p>第一个命令是告诉Git要追踪什么文件，第二个命令是进行提交，并对此次提交做个简答说明。当然，今后他再对README做什么修改，都可以这样做。Git会自动为此次提交生成一个16进制的版本号。</p><p>如果此时他查看本地的版本库，就会发现最新的一次提交是在刚才，提交说明为：<code>add README</code>。</p><p>此时，就已经使用<code>git commit</code>命令创建了一个文件版本记录，该版本被自动保存在本地的<strong>版本库</strong>中（<code>.git/</code>）。</p><p>最后，他要把<strong>项目的版本库</strong>更新到Gitlab上，当然这时候项目本身已经在Gitlab上建立好了。他只需要：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> main</span><br></pre></td></tr></table></figure><p>这行命令应该这样理解：A已经在本地把项目最新的版本做好了，他要发到Gitlab上，以便团队里其他人都能收到这个新的版本，于是他运行<code>git push</code>；push的目的地是<code>origin</code>，这其实是个名字，意义为该项目在Gitlab上的地址；推送的是本地的<code>main</code>分支。</p><p>这个时候，Gitlab上项目的版本号与A本地的最新版本号一致。</p><blockquote><p>分支是版本控制里面的一个概念：在项目做大了之后，如果要在原基础上进行扩展开发，最好新建一个分支，以免影响原项目的正常维护，新的分支开发结束后再与原来的项目分支合并；而在一个项目刚开始的时候，大家一般会在同一个分支下进行开发.这是一种相对安全便捷的开发方式。</p></blockquote><p>此时，小组里成员B对项目其他文件做了一些更改，同样也在本地做了一次提交，然后也想推到Gitlab上面。他运行了<code>git push origin main</code>命令，结果发现提交被拒绝。这要做如何解释？</p><p>仔细想想，最开始的时候，A和B是在同一个版本号上做不同的更改，这就会分别衍生出两个不同的版本号。A先把自己的版本推到Gitlab上，此时Gitlab上的版本库与B本地版本库相比，差异很大，主要在于B这里没有A的版本记录，如果B这时把自己的版本强制<strong>同步</strong>到Gitlab上，就会把A的版本覆盖掉，这就出问题了。</p><p>所以B进行了如下操作：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git pull</span><br></pre></td></tr></table></figure><p>这样子，B先把Gitlab上的版本库和自己的版本库做一个合并，这个合并的意义在于：B通过Gitlab，把A刚才添加的版本加了进来，此时B本地的版本库是整个项目最新的，包括项目之前的版本、刚刚A添加的版本和B自己添加的版本。</p><p>这之后，B再次运行<code>git push origin main</code>，成功地把自己的版本推到了Gitlab上。如果A想要推送新的版本，也要像B之前这样折腾一番才行。</p><h3 id="还能再给力点么？"><a href="#还能再给力点么？" class="headerlink" title="还能再给力点么？"></a>还能再给力点么？</h3><p>当然可以！</p><p>这里有两个在线代码托管平台：</p><ul><li><a href="https://github.com" target="_blank" rel="noopener">Github</a></li><li><a href="https://Gitlab.com" target="_blank" rel="noopener">Gitlab</a></li></ul><p>还有一些优秀的Git在线资料：</p><ul><li><a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">Git使用简易指南</a></li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程-廖雪峰</a></li><li><a href="https://Gitlab.com/grant/GitTips" target="_blank" rel="noopener">更多资料</a></li></ul><p>最后还有一本不错的中文书籍：</p><ul><li><a href="http://book.douban.com/subject/6526452/" target="_blank" rel="noopener">《Git权威指南》（蒋鑫）</a></li></ul><p>不过，本文就要到此为止了，因为再往下写就会涉及更多更深的Git操作实践，而这些内容在上面给出的资料中已经整理好。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文的目的在于解决身边乃至更多开发者同时入门版本控制和Git时候遇到的困惑，希望能对各位初学者起到积极的作用。</p><p>如果您有更好的意见或建议，欢迎与我讨论：）</p>]]></content>
    
    <summary type="html">
    
      一份新手友好的Git入门指南
    
    </summary>
    
      <category term="technology" scheme="http://blog.oripd.com/categories/technology/"/>
    
    
      <category term="git" scheme="http://blog.oripd.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>RESTful Web</title>
    <link href="http://blog.oripd.com/2014/05/01/restful-web/"/>
    <id>http://blog.oripd.com/2014/05/01/restful-web/</id>
    <published>2014-04-30T16:00:00.000Z</published>
    <updated>2020-12-17T07:08:38.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是Horizon第二次线下活动中“RESTful Web”讲题的总结，由Alvin Qi整理。</p></blockquote><p>REST的全称是Representational State Transfer，可译为“表征状态转移”，是Roy Fielding博士在2000年他的博士论文中提出的一种软件架构风格。目前，在三中主流的Web服务实现方式中，与SOA和RPC相比，REST的实现更为简洁，因而得到越来越多的商业公司和开发者的青睐。</p><p>本文将简单介绍给读者，如何理解REST、以及举例说明在开发场景的简单应用。</p><h2 id="REST从哪里来"><a href="#REST从哪里来" class="headerlink" title="REST从哪里来?"></a>REST从哪里来?</h2><p>在理解REST之前，先要对Web和Web Service有一个简单的认识。</p><p>一切还要从互联网诞生说起。互联网从诞生至今，经历了几个发展阶段：</p><ul><li><p>阶段一：静态内容阶段</p><p>互联网本身是为欧美各高校/研究院共享信息而诞生的，在最初的那个年代，能访问到的互联网内容全都是文本内容（很多是于科研有关的论文、资料），所谓的Web服务器更像是一台支持解析超文本的文件共享服务器。</p></li><li><p>阶段二：CGI程序阶段</p><p>后来人们想在Web上加入更多的<strong>功能</strong>，而非原先简单的超文本解析。这就需要Web服务器提供可用的API，通过程序与客户端进行通信，达到内容交互的作用。服务器与客户端程序的通信由CGI（通用网关接口）协议来完成，而这些用于通信的程序就叫做CGI程序。</p></li><li><p>阶段三：脚本语言阶段</p><p>CGI程序有相对较高的安全隐患和开发难度。后来，在服务器端就出现了PHP、ASP、JSP等支持session的脚本语言，浏览器端也诞生了JavaScript、Java Applet，这大大降低了Web开发的难度，而互联网上的内容与交互形式也变得更为丰富。</p></li><li><p>阶段四：Thin Client App阶段</p><p>脚本语言易于开发，但大量的堆积却不利于项目的维护，所以就有人提出了MVC开发模式，也就渐渐诞生了各类MVC开发框架。同时，也诞生了独立于Web服务器的应用服务器，这就为瘦客户端应用提供了有力的发展条件。在这个阶段里，瘦客户端不再简单的解析HTML、执行JavaScript，而是单独执行其他的程序代码，从而提供了极为丰富的人机交互方式。互联网也变得更加精彩。</p></li><li><p>阶段五：Rich Internet App阶段</p><p>层出不穷的瘦客户端技术令开发者头晕目眩，而这时传统的Web技术有了新的发展，给开发者提供了互联网内容和交互形式都可兼得的选择。这期间，以JavaScript为核心的前端技术高速发展，诞生了Ajax、jQuery、ExtJs等模式与框架。这些技术一直到现在都炙手可热。</p></li><li><p>阶段六：Mobile App阶段</p><p>iOS的诞生使移动互联网爆发性增长，后来也有Android和Windows Phone加入，而从前的前端技术也同时顾及桌面端和移动端。原生移动平台开发很受欢迎的同时，基于HTML5的开发技术也变得很流行。</p></li></ul><p>从这个过程来看，Web变得越来越复杂；为了支持这样庞大的互联网，背后的技术也在不断更新。当CGI乃至服务器端脚本语言出现后，HTTP/1.0便无法满足Web开发的要求，HTTP/1.1应运而生，其作者之一的Roy Fielding博士在HTTP/1.1的基础上推导出了一种全新的软件架构风格，也就是REST。</p><p>说到REST，就必须先对Web Service有一个基本的认识。</p><p>Web服务，直观的认识可以是“万维网上的一套消息传递机制”；实际上，W3C组织给出了精准的定义：<strong>Web服务应带是一个软件系统，用以支持网络间不同机器的互动操作，网络服务通常是由许多API组成，它们通过网络来执行客户提交的各种请求。</strong></p><p>看过这个较为抽象的定义后，如果感觉吃不消，可以结合Web服务的使用方式来进一步理解。</p><p>Web服务有三种普遍的实现方式，分别是：RPC，SOA，REST。</p><ul><li><p>远程过程调用（RPC）</p><p>这是一种早期的Web服务实现方式，最容易理解，要求Web服务提供一个分布式函数或方法接口供用户调用。就好比把一套系统的函数、方法（包含参数）提供给开发者（这样做同时也会把部分信息暴露在开放的互联网上）。<br>这里给出一组例子，可以感受一下。</p><p><strong>Server端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getUser(id)</span><br><span class="line">  addUser(id, name)</span><br><span class="line">  removeUser(id)</span><br><span class="line">  updateUser(id, attr)</span><br><span class="line">  getLocation(id)</span><br><span class="line">  addLocation(id, Px, Py)</span><br><span class="line">  removeLocation(id)</span><br><span class="line">  updateLocation(id, Px, Py)</span><br></pre></td></tr></table></figure><p><strong>Client端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exampleAppObject = <span class="keyword">new</span> ExampleApp(<span class="string">"example.com:1234"</span>)</span><br><span class="line">exampleAppObject.getUser(id)</span><br></pre></td></tr></table></figure><p>这样做的弊端在于耦合性强和安全性差。当一套系统变得庞大时，组织合理的函数、方法接口将会变得非常繁琐；而且接口和程序语言有一定的关联，这样也限制了开发者。</p></li><li><p>服务导向架构（SOA）</p><p>现在，业界关注的重点是遵从服务导向架构（Service-oriented Architecure）来构建的Web服务。在这种架构中，通讯由消息驱动，而不是再由某个具体的动作（函数或方法调用）来实现。这种方式与RPC的最大区别是，更加关注如何去连接服务，而非关心特定细节的实现。关于SOA的更详细的资料可以查阅互联网。</p></li><li><p>表征状态转移（REST）</p><p>表征状态转移类型的Web服务类似HTTP或其他协议，<strong>它们以资源为核心，把接口限定在一组广为人知的标准动作中（如GET, PUT, DELETE等），以供调用</strong>。这类Web服务与前面两个相比，更加关注资源本身，而非消息或动作。<br>下面再给出一组例子。</p><p><strong>Server端</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/example.com/users</span><span class="regexp">/</span></span><br><span class="line"><span class="regexp">http:/</span><span class="regexp">/example.com/users</span><span class="regexp">/&#123;user&#125;</span></span><br><span class="line"><span class="regexp">http:/</span><span class="regexp">/example.com/find</span>UserForm</span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/example.com/locations</span></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/example.con/locations</span><span class="regexp">/&#123;location&#125;</span></span><br><span class="line"><span class="regexp">http:/</span><span class="regexp">/example.com/find</span>LocationForm</span><br></pre></td></tr></table></figure><p><strong>Client端</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userResource = new Resource(<span class="string">"http://example.com:1234"</span>)</span><br><span class="line">userResource.get(<span class="symbol">:id</span>)</span><br></pre></td></tr></table></figure><p>显然，这种Web服务的方式并不受限于编程语言种类，组织庞大的URI也不是很繁琐，而且以资源为核心，以HTTP协议为基础，更便于在互联网上传播。<br>所以，<strong>现在的互联网就是由各个Web服务构成的</strong>，从程序的角度来看，好像就是这样。</p></li></ul><p>但作为普通网民，真的难以理解上面讨论的内容，因为他们才不管什么RPC/SOA/REST，他们只关心互联网的内容。所以，我们可以拓宽对“Web服务”的理解，把Web服务看做是两部分：</p><ul><li><p>面向人类用户的Web服务</p><p>也就是我们打开浏览器、App所访问的Web内容。</p></li><li><p>面向程序/程序员的Web服务</p><p>如上所说的一套软件系统，最关键的是那组API。</p></li></ul><p>所以，互联网还是由各类Web服务组成的，这就又回到了RESTful Web的话题上。</p><p>以上，可以认为：<strong>RESTful Web就是以HTTP/1.1为基础，以资源为核心提供的现代Web服务</strong>，而“表征状态转移”就作为一种架构风格（或规范）存在，而非业界标准。</p><h2 id="怎样才能REST？"><a href="#怎样才能REST？" class="headerlink" title="怎样才能REST？"></a>怎样才能REST？</h2><p>前面说的网站、Web服务，其实都是存在于生产环境中的分布式Web系统。所以要想做到REST，我们可以假象有一个“初始化”的Web分布式系统，给它加上约束条件，使之成为RESTful的系统。</p><p>REST架构风格中最重要的架构约束有6个：</p><ul><li><p>客户-服务器</p><p><img src="/images/binding1.png" alt></p><p>由客户端发出“请求”，作为通信的开始，服务器进行“响应”。</p></li><li><p>无状态</p><p><img src="/images/binding2.png" alt></p><p>仅由客户端负责维护通信的会话状态</p></li><li><p>缓存</p><p><img src="/images/binding3.png" alt></p><p>响应的内容应该可以在通信链的某个环节被缓存，以改善网络效率。</p></li><li><p>统一接口</p><p><img src="/images/binding4.png" alt></p><p>“客户端-服务器”通信链组件之间应通过统一的软件接口来实现通信，从而提高交互的可见性。</p></li><li><p>分层系统</p><p><img src="/images/binding5.png" alt></p><p>限制各组件的行为，实现通信链上下游分层。</p></li><li><p>按需代码</p><p><img src="/images/binding6.png" alt></p><p>支持下载并执行一些代码（如JavaScript），对客户端功能进行扩展。</p></li></ul><p>这其中，第六个约束是可选特性，也就是说仅符合前五个约束的Web分布式系统也可以看做是满足REST设计风格的。</p><h2 id="但是，究竟怎样才能做到RESTful？"><a href="#但是，究竟怎样才能做到RESTful？" class="headerlink" title="但是，究竟怎样才能做到RESTful？"></a>但是，究竟怎样才能做到RESTful？</h2><p>对于软件架构师，可以顺着上面的思路，最终能推导出一套满足REST的软件系统；而对于程序员也许更简单——使用支持REST的开发框架。但框架也有正确的使用方式，对于这类框架，就需要用符合REST规范的编程方法。</p><h3 id="规范使用HTTP动词"><a href="#规范使用HTTP动词" class="headerlink" title="规范使用HTTP动词"></a>规范使用HTTP动词</h3><p>HTTP/1.1规范规定了八个动词：<code>OPTION, HEAD, GET, POST, PUT, DELETE, TRACE, CONNECT</code>，分别代表了不同的语义，其中<code>GET, PUT, POST, DELETE</code>就是CRUD的语义化动词，在开发Web系统中非常常用。</p><p>强调规范使用这些动词，是因为有不规范的情况出现。比如<code>GET</code>，作为一个安全动词，原本是用于发出查找请求。下面有两个不好的例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add cart</span></span><br><span class="line">GET /add_cart?pid=<span class="number">1234</span> HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="symbol">Host:</span> www.example.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete note</span></span><br><span class="line">GET /notes/delete?id=<span class="number">1234</span> HTTP/<span class="number">1.1</span></span><br><span class="line"><span class="symbol">Host:</span> www.example.org</span><br></pre></td></tr></table></figure><p>本来是用于请求查询的报文却在请求增加/减少资源。这样写的程序可以执行，但有非常大的隐患，有可能在未知的情况下造成数据的大量变动，比如一些缓存程序或恶意攻击。</p><h3 id="合理命名资源"><a href="#合理命名资源" class="headerlink" title="合理命名资源"></a>合理命名资源</h3><p>资源可以看做是一个Web系统的核心，因为不论业务逻辑怎么复杂，都是对数据进行增删改查。但资源不同于数据，资源要有名称，而且是可以在万维网上可以定位到资源本身的名称——也就是URI（Uniform Resource Identifier）。所以资源命名就尤为重要，<strong>以满足易于编程和用户可读为标准</strong>。看下面这些例子，就能体会到。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST   <span class="symbol">http:</span>/<span class="regexp">/example.com/customers</span></span><br><span class="line">GET    <span class="symbol">http:</span>/<span class="regexp">/example.com/customers</span><span class="regexp">/123</span></span><br><span class="line"><span class="regexp">DELETE http:/</span><span class="regexp">/example.com/products</span><span class="regexp">/123</span></span><br><span class="line"><span class="regexp">PUT    http:/</span><span class="regexp">/example.com/customers</span><span class="regexp">/123/orders</span><span class="regexp">/45</span></span><br></pre></td></tr></table></figure><p>真实的互联网还有更多形象的例子，它们那样良好的命名设计使得不论是普通用户还是开发人员都能更方便地在网上完成相关业务，这也是REST优势的一点体现。</p><h3 id="利用HTTP响应码指示状态"><a href="#利用HTTP响应码指示状态" class="headerlink" title="利用HTTP响应码指示状态"></a>利用HTTP响应码指示状态</h3><p>状态响应码是HTTP协议中规定的一部分。协议中规定了很多组数字，用来表示网络中可能发生的最常见的情况。如果需要开发Web系统的API，那么就需要按照HTTP报文的要求，为响应报文中提供准确的响应代码，以区分相关请求的执行状态。</p><p>比如在客户端执行了某个<code>GET</code>请求，API通常需要返回200，表示请求成功，其他情况则按照需要返回403、404、405等。</p><p>这里列出几个常用的响应码：</p><ul><li>200 OK</li><li>201 CREATED</li><li>204 NO CONTENT</li><li>400 BAD REQUEST</li><li>401 UNAUTHORIZED</li><li>403 FORBIDDEN</li><li>404 NOT FOUND</li><li>405 METHOD NOT ALLOWED</li><li>409 CONFLICT</li><li>500 INTERNAL SERVER ERROR</li></ul><h2 id="还有什么？"><a href="#还有什么？" class="headerlink" title="还有什么？"></a>还有什么？</h2><p>是的，关于REST还有非常多的内容，但本文到这里就要告一段落了，而想要深入了解REST的特性，乃至构建自己的RESTful Web系统，到此为止是远远不够的。</p><p>目前的主流编程语言，如Java、PHP、Python、Ruby、Node.js、C#等，都已经实现了各自的支持REST的编程框架，可以根据兴趣选择其中之一来学习并实践。</p><p>这里还有重要的阅读资料，以便深入研究REST架构范式：</p><ul><li><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener">《Architectural Styles and the Design of Network-based Software Architectures》</a></li><li><a href="http://book.douban.com/subject/2054201/" target="_blank" rel="noopener">《Restful Web Service》</a></li><li><a href="http://book.douban.com/subject/4018013/" target="_blank" rel="noopener">《RESTful Web Services Cookbook》</a></li><li><a href="http://book.douban.com/subject/4791069/" target="_blank" rel="noopener">《REST in Practice》</a></li></ul>]]></content>
    
    <summary type="html">
    
      Horizon第二次线下活动演讲总结，讲解有关RESTful方面的知识
    
    </summary>
    
      <category term="technology" scheme="http://blog.oripd.com/categories/technology/"/>
    
    
      <category term="REST" scheme="http://blog.oripd.com/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>基于Capistrano工具的Rails程序部署方案</title>
    <link href="http://blog.oripd.com/2014/02/12/deploy-rails-with-capistrano/"/>
    <id>http://blog.oripd.com/2014/02/12/deploy-rails-with-capistrano/</id>
    <published>2014-02-12T09:40:30.000Z</published>
    <updated>2020-12-17T07:08:18.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于Capistrano 2版本，文中的命令不一定适用于Capistrano 3。</p></blockquote><h1 id="什么是Capistrano？"><a href="#什么是Capistrano？" class="headerlink" title="什么是Capistrano？"></a>什么是Capistrano？</h1><p>简单地讲，Capistrano是一个<code>gem</code>。对于不太熟悉Ruby的朋友来说，<code>gem</code>就是一套按照一定规范打包好的Ruby代码，可以类比Java里面的Package。</p><p>实际上，Capistrano是专门用来部署rails程序的一套工具。</p><h1 id="为什么用它？"><a href="#为什么用它？" class="headerlink" title="为什么用它？"></a>为什么用它？</h1><p>Rails应用程序的部署方案十分灵活，适应于不同的生产服务器场景。在实际生产中，rails程序中包含的各类gem和生产服务器上的gem往往版本不一致，这就为部署增加了一些难度。</p><p>利用Capistrano进行部署，就能很容易解决这个问题。同时，使用Capistrano部署rails程序，更有一种“敏捷”的感觉。</p><p>在进行Rails开发过程中，一个重要的工具就是版本控制，而我们经常用Git。用过Heroku的开发者，或者有静态博客的朋友都能感受到一点——把版本控制与部署方案融合到一起非常方便。幸运的是，Capistrano对包括Git在内的各类版本控制有非常好的支持。本文中，我将使用Git作为版本控制软件，与Capistrano一起工作，进行项目部署。</p><h1 id="如何部署？"><a href="#如何部署？" class="headerlink" title="如何部署？"></a>如何部署？</h1><p>利用Capistrano部署Rails程序，可以分为下面四个步骤。</p><ul><li>配置部署服务器</li><li>对应用程序进行版本控制</li><li>远程部署应用程序</li><li>版本控制推进部署</li></ul><h2 id="配置部署服务器"><a href="#配置部署服务器" class="headerlink" title="配置部署服务器"></a>配置部署服务器</h2><blockquote><p>对生产服务器的基本配置，包括Web静态服务器、数据库、版本控制搭建、防火墙等的控制不在本文讨论范围内。它们之中任何一点拿出来都够写一本书了。</p></blockquote><p>首先，要在部署服务器可以访问到的地方创建一个新的版本库。</p><p>读者可以在公司/实验室里搭建GitLab，或者连接到GitHub上。如果是自己搭建GitLab，其实完全可以把Git服务器和生产服务器放在同一台机器上。可以通过以下命建立Server端的远程版本库，也可以通过访问Git服务器的Web界面自行操作。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mkdir -p ~<span class="regexp">/git/project</span>.git</span><br><span class="line"><span class="variable">$ </span>cd ~<span class="regexp">/git/project</span>.git</span><br><span class="line"><span class="variable">$ </span>git --bare init</span><br></pre></td></tr></table></figure><p>值得注意的是，即使是把Git Server和Web Server放在同一台机器上，Capistrano也是通过Web服务的形式访问Git。这里可以配置公钥来简化整个流程。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ test -e ~<span class="regexp">/.ssh/id</span>_dsa.pub <span class="params">||</span> ssh-keygen -t dsa</span><br><span class="line">$ cat ~<span class="regexp">/.ssh/id</span>_dsa.pub &gt;&gt; ~<span class="regexp">/.ssh/authorized</span>_keys</span><br></pre></td></tr></table></figure><p>还有一件非常重要的事情：Capistrano将在应用程序目录名和Rails子目录中插入名为<code>current</code>的目录，其中包括<code>public</code>子目录。在用Capistrano部署好的项目中，目录结构类似下面的样子（<code>current</code>是当前部署的版本，<code>releases</code>是该分支下根据版本生成的曾经的项目，<code>shared</code>中是各个版本共享的资源）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls project</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> current  releases  shared</span></span><br></pre></td></tr></table></figure><p>而这个<code>public</code>目录就是我们熟悉的Rails程序中静态资源目录；也就是说，不论你用Apache或Ngnix还是其他Web服务器来部署静态资源，需要把这个目录设置为根目录。以Apache配置为例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentRoot <span class="regexp">/home/</span><span class="keyword">project</span><span class="regexp">/current/</span><span class="keyword">public</span><span class="regexp">/</span></span><br></pre></td></tr></table></figure><p>到此为止，对服务器的预先配置就已经完成了，接下来的工作都可以在开发环境中完成。</p><h2 id="对应用进行版本控制"><a href="#对应用进行版本控制" class="headerlink" title="对应用进行版本控制"></a>对应用进行版本控制</h2><p>最开始，要在项目的Gemfile中加入Capistrano gem：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">...</span></span><br><span class="line">gem <span class="string">'capistrano'</span></span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure><p>然后执行命令<code>bundle install</code>来安装gem。接下来执行一条很重要的命令，它的作用是把项目中用到的gem及其版本号都记录下来：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> bundle pack</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后可以做一个版本记录，并推送到远程库</span></span><br><span class="line"><span class="symbol">$</span> git add .</span><br><span class="line"><span class="symbol">$</span> git commit -m <span class="string">"install capistrano &amp; bundle gems"</span></span><br><span class="line"><span class="symbol">$</span> git push origin master</span><br></pre></td></tr></table></figure><p>以上，已经完成了项目gem整理。接下来我们要把项目代码放入生产环境。</p><h2 id="远程部署应用程序"><a href="#远程部署应用程序" class="headerlink" title="远程部署应用程序"></a>远程部署应用程序</h2><p>接下来的过程，我们可以先猜测一下：</p><ul><li>把代码pull到服务器的DocumentRoot</li><li>在生产服务器上生成数据库</li><li>安装gem</li><li>重启Passenger</li><li>……</li></ul><p>这些事情，可以想到的话，就可以手动来做；但是等下，要Capistrano是做什么的……<br>没错，到了这一步，就可以显示Capistrano的威力了：自动化部署。以上的事情可以全交给它来做，当然前提是要写一份自动化部署的脚本。</p><p>首先，在开发环境的项目根目录中执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> capify</span></span><br><span class="line">[add] writing './Capfile'</span><br><span class="line">[add] writing './config/deploy.rb'</span><br><span class="line">[done] capified!</span><br><span class="line"></span><br><span class="line">// Capistrano3中使用下面的命令</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cap</span> install</span></span><br></pre></td></tr></table></figure><p>现在多出来了两个文件：<code>Capfile</code>和<code>deploy.rb</code>，前者是Capistrano对Rakefile的模拟，不需要改动，后者是一个自动化的脚本，需要编辑的就是这个。这个文件里需要用到一些Capistrano的DSL，可以看<a href="https://github.com/capistrano/capistrano/wiki/2.x-Getting-Started" target="_blank" rel="noopener">这里</a>参考。在此给出一份比较简单的脚本作为参考，它是上面命令生成的默认脚本。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config valid only for Capistrano 3.1</span></span><br><span class="line">lock <span class="string">'3.1.0'</span></span><br><span class="line"></span><br><span class="line">set <span class="symbol">:application</span>, <span class="string">'my_app_name'</span></span><br><span class="line">set <span class="symbol">:repo_url</span>, <span class="string">'git@example.com:me/my_repo.git'</span></span><br><span class="line"></span><br><span class="line">namespace <span class="symbol">:deploy</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  desc <span class="string">'Restart application'</span></span><br><span class="line">  task <span class="symbol">:restart</span> <span class="keyword">do</span></span><br><span class="line">    on roles(<span class="symbol">:app</span>), <span class="symbol">in:</span> <span class="symbol">:sequence</span>, <span class="symbol">wait:</span> <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># Your restart mechanism here, for example:</span></span><br><span class="line">      <span class="comment"># execute :touch, release_path.join('tmp/restart.txt')</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  after <span class="symbol">:publishing</span>, <span class="symbol">:restart</span></span><br><span class="line"></span><br><span class="line">  after <span class="symbol">:restart</span>, <span class="symbol">:clear_cache</span> <span class="keyword">do</span></span><br><span class="line">    on roles(<span class="symbol">:web</span>), <span class="symbol">in:</span> <span class="symbol">:groups</span>, <span class="symbol">limit:</span> <span class="number">3</span>, <span class="symbol">wait:</span> <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># Here we can do anything such as:</span></span><br><span class="line">      <span class="comment"># within release_path do</span></span><br><span class="line">        <span class="comment">#   execute :rake, 'cache:clear'</span></span><br><span class="line">      <span class="comment"># end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在修改好<code>:application</code>、<code>:repo_url</code>等值后，就可以开始进行部署了。<br>第一次部署的时候，请运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cap</span> deploy:setup</span></span><br></pre></td></tr></table></figure><p>之后会要求输入服务器密码。连接成功后会在生产服务器上生成必要的目录。</p><p>如果想测试配置，看还有没有别的问题，可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cap</span> deploy:check</span></span><br></pre></td></tr></table></figure><p>一旦解决完所有问题，就可以运行下面的命令，进行数据库生成，并完成部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cap</span> deploy:migrate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cap</span> deploy</span></span><br></pre></td></tr></table></figure><p>至此，就已经把项目部署到生产服务器上了。</p><h2 id="版本控制推进部署"><a href="#版本控制推进部署" class="headerlink" title="版本控制推进部署"></a>版本控制推进部署</h2><p>已经部署完了么？</p><p>并不是这样的，不要忽视掉最开始强调版本控制的用意。Capistrano能让你在持续开发的情况下进行版本推进部署，而操作非常简单。每次做好提交、并把版本库推送到远端后，就可以运行<code>cap deploy</code>进行部署。</p><p>如果有某些原因，需要回到上一个部署的版本，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cap</span> deploy:rollback</span></span><br></pre></td></tr></table></figure><h1 id="这就完了？"><a href="#这就完了？" class="headerlink" title="这就完了？"></a>这就完了？</h1><p>没错！整个部署的过程就是这样。</p><p>如果想掌握关于它的高级用法，可以看<a href="https://github.com/capistrano/capistrano/wiki" target="_blank" rel="noopener">Wiki</a>文档。</p><p>本文只是以Rails为例讲解了Capistrano的用法，实际上它还可以用来部署其他语言写的Web应用程序，比如Java、PHP、Python等，读者有兴趣的话可以继续探索下去。</p>]]></content>
    
    <summary type="html">
    
      本文基于Capistrano 2版本，文中的命令不适用于Capistrano 3
    
    </summary>
    
      <category term="technology" scheme="http://blog.oripd.com/categories/technology/"/>
    
    
      <category term="rails" scheme="http://blog.oripd.com/tags/rails/"/>
    
  </entry>
  
  <entry>
    <title>Git Hooks (II)：脚本分类</title>
    <link href="http://blog.oripd.com/2013/12/10/git-hooks-ii/"/>
    <id>http://blog.oripd.com/2013/12/10/git-hooks-ii/</id>
    <published>2013-12-09T16:00:00.000Z</published>
    <updated>2020-12-17T07:08:11.308Z</updated>
    
    <content type="html"><![CDATA[<p>上篇中提到一个Git Hooks列表，如下：</p><ul><li>applypatch-msg</li><li>pre-applypatch</li><li>post-applypatch</li><li>pre-commit</li><li>prepare-commit-msg</li><li>commit-msg</li><li>post-commit</li><li>pre-rebase</li><li>post-checkout</li><li>post-merge</li><li>pre-receive</li><li>update</li><li>post-receive</li><li>post-update</li><li>pre-auto-gc</li><li>post-rewrite</li></ul><p>这些脚本可以按照运行环境分为两类：本地Hooks与服务端Hooks。</p><h3 id="Client-Side"><a href="#Client-Side" class="headerlink" title="Client Side"></a>Client Side</h3><p>也就是上面提到的本地hooks。<br>其实本地hooks还是占大多数的，可以给它们分成三类：</p><ul><li>commit hooks</li><li>e-mail hooks</li><li>其他</li></ul><h4 id="Commit-Hooks"><a href="#Commit-Hooks" class="headerlink" title="Commit Hooks"></a>Commit Hooks</h4><p>与<code>git commit</code>相关的hooks一共有四个，均由<code>git commit</code>命令触发调用，按照一次发生的顺序分别是：</p><ul><li><code>pre-commit</code></li><li><code>prepare-commit-msg</code></li><li><code>commit-msg</code></li><li><code>post-commit</code></li></ul><p>其中，<code>pre-commit</code>是最先触发运行的脚本。在提交一个commit之前，该hook有能力做许多工作，比如检查待提交东西的快照，以确保这份提交中没有缺少什么东西、文件名是否符合规范、是否对这份提交进行了测试、代码风格是否符合团队要求等等。<br>这个脚本可以通过传递<code>--no-verify</code>参数而禁用，如果脚本运行失败（返回非零值），git提交就会被终止。</p><p><code>prepare-commit-msg</code>脚本会在默认的提交信息准备完成后但编辑器尚未启动之前运行。<br>这个脚本的作用是用来编辑commit的默认提交说明。<br>该脚本有1~3个参数：包含提交说明文件的路径，commit类型（<code>message</code>, <code>template</code>, <code>merge</code>, <code>squash</code>），一个用于commit的SHA1值。这个脚本用的机会不是太多，主要是用于能自动生成commit message的情况。<br>该不会因为<code>--no-verify</code>参数而禁用，如果脚本运行失败（返回非零值），git提交就会被终止。</p><p><code>commit-msg</code>包含有一个参数，用来规定提交说明文件的路径。<br>该脚本可以用来验证提交说明的规范性，如果作者写的提交说明不符合指定路径文件中的规范，提交就会被终止。<br>该脚本可以通过传递<code>--no-verify</code>参数而禁用，如果脚本运行失败（返回非零值），git提交就会被终止。</p><p><code>post-commit</code>脚本发生在整个提交过程完成之后。这个脚本不包含任何参数，也不会影响commit的运行结果，可以用于发送new commit通知。</p><p>需要注意到，这几个脚本并不会通过clone传到项目中，而且既然是完全运行在本地，那就无法完全保证验证能起到作用（可以随便修改），但为了保证一些项目的可靠性，还需要开发者们自觉遵守这些规则。</p><h4 id="E-mail-Hooks"><a href="#E-mail-Hooks" class="headerlink" title="E-mail Hooks"></a>E-mail Hooks</h4><p>与<code>git am</code>相关的脚本由三个，均由<code>git am</code>触发运行，按顺序依次是：</p><ul><li><code>applypatch-msg</code></li><li><code>pre-applypatch</code></li><li><code>post-applypaych</code></li></ul><p>如果在工作流中用不到这个命令，那也就无所谓了。不过，如果要用<code>git format-patch</code>命令通过Email提交补丁，这部分内容还是比较有用的。</p><p><code>applypatch-msg</code>脚本最先被触发，它包含一个参数，用来规定提交说明文件的路径。该脚本可以修改文件中保存的提交说明，以便规范提交说明以符合项目标准。如果提交说明不符合规定的标准，脚本返回非零值，git终止提交。</p><p>说明一点，这个脚本看上去和<code>commit-msg</code>作用几乎一样。没错，默认情况下该脚本是这样写的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">. git-sh-setup</span><br><span class="line"><span class="built_in">test</span> -x <span class="string">"<span class="variable">$GIT_DIR</span>/hooks/commit-msg"</span> &amp;&amp;</span><br><span class="line">       <span class="built_in">exec</span> <span class="string">"<span class="variable">$GIT_DIR</span>/hooks/commit-msg"</span> <span class="variable">$&#123;1+"$@"&#125;</span></span><br><span class="line">:</span><br></pre></td></tr></table></figure><p>也就是说，该脚本会调用<code>commit-msg</code>并执行。实际上，这一切都是可修改的。</p><p><code>pre-applypatch</code>会在补丁应用后但尚未提交前运行。这个脚本没有参数，可以用于对应用补丁后的工作区进行测试，或对git tree进行检查。如果不能通过测试或检查，脚本返回非零值，git终止提交。<br>同样需要注意，git提供的此默认脚本中只是简单调用了<code>pre-commit</code>，因此在实际工作中需要视情况修改。</p><p><code>post-applypatch</code>脚本会在补丁应用并提交之后运行，它不包含参数，也不会影响git am的运行结果。该脚本可以用来向工作组成员或补丁作者发送通知。</p><h4 id="其他Hooks"><a href="#其他Hooks" class="headerlink" title="其他Hooks"></a>其他Hooks</h4><ul><li><code>pre-rebase</code></li></ul><p>由<code>git rebase</code>命令调用，运行在rebase执行之前，可以用来阻止任何已发发生过的提交参与变基（字面意思，找不到合适的词汇了）。默认的<code>pre-rebase</code>确实是这么做的，不过脚本中的<code>next</code>是根据Git项目自身而写的分支名，在使用过程中应该将其改成自己的稳定分支名称。</p><ul><li><code>post-checkout</code></li></ul><p>由<code>git checkout</code>命令调用，在完成工作区更新之后执行。该脚本由三个参数：之前HEAD指向的引用，新的HEAD指向的引用，一个用于标识此次检出是否是分支检出的值（0表示文件检出，1表示分支检出）。</p><p>也可以被<code>git clone</code>触发调用，除非在克隆时使用参数<code>--no-checkout</code>。在由clone调用执行时，三个参数分别为<code>null, 1, 1</code>。</p><p>这个脚本可以用于为自己的项目设置合适的工作区，比如自动生成文档、移动一些大型二进制文件等，也可以用于检查版本库的有效性。</p><ul><li><code>post-merge</code></li></ul><p>由<code>git merge</code>调用，在merge成功后执行。该脚本有一个参数，标识合并是否为压缩合并。该脚本可以用于对一些Git无法记录的数据的恢复，比如文件权限、属主、ACL等。</p><h3 id="Server-Side"><a href="#Server-Side" class="headerlink" title="Server Side"></a>Server Side</h3><p>除了本地执行的Hooks脚本之外，还有一些放在Git Server上的Hooks脚本，作为管理员，可以利用这些服务端的脚本来强制确保项目的任何规范。这些运行在服务端的脚本，会在push命令发生的前后执行。<code>pre</code>系列的脚本可以在任何时候返回非零值来终止某次push，并向push方返回一个错误说明。</p><p>这里简单介绍这几个脚本：</p><ul><li><code>pre-receive</code></li></ul><p>由服务器端的<code>git receive-pack</code>命令调用，当从本地版本库完成一个推送之后，远端服务器开始批量更新之前，该脚本被触发执行。该脚本会从标准输入中读入一连串push过来的引用，如果这里面存在任何非零值，这批更新将不会被服务器接受。可以利用这个脚本来检查推送过来的提交是否合法。</p><ul><li><code>post-receive</code></li></ul><p>由服务器端的<code>gir receive-pack</code>命令调用，当从本地版本库完成一个推送，并且在远程服务器上所有引用都更新完毕后执行。该脚本可以用于对其他镜像版本库的更新，或向用户发送提示（直接通过服务器端的echo命令）。如上文我提到的利用Git实现生产代码的自动化部署，就可以通过这个脚本完成。</p><ul><li><code>update</code><br>这是一个强大的hook脚本。它和<code>pre-recieve</code>有些类似，只是它会为推送过来的更新中涉及到的每一个分支都做一次检查，而后者则至始至终只有一次检查。另外，它不是从标准输入中读取数据，而是包含三个参数：<ul><li>要更新的引用或分支的名称</li><li>引用中保存的旧对象名称（SHA1）</li><li>将要保存到引用中的新对象名称(SHA1)</li></ul></li></ul><p>如果检查到返回非零值，之后返回非零值的引用会被拒绝，其他正常的引用更新都会被接受。除此之外，该脚本还可以用来防止引用被强制更新，因为它可以通过这些参数来检查新旧引用对象中是否存在继承关系，从而提供更细致的推送授权。</p><p>在Gitolite中，该脚本有更强大的应用实例。</p><blockquote><p>本篇完结，敬请期待后续……</p></blockquote>]]></content>
    
    <summary type="html">
    
      通过示例理解Git Hooks
    
    </summary>
    
      <category term="technology" scheme="http://blog.oripd.com/categories/technology/"/>
    
    
      <category term="git" scheme="http://blog.oripd.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git Hooks (I): 介绍</title>
    <link href="http://blog.oripd.com/2013/12/10/git-hooks-i/"/>
    <id>http://blog.oripd.com/2013/12/10/git-hooks-i/</id>
    <published>2013-12-09T16:00:00.000Z</published>
    <updated>2020-12-17T07:08:07.204Z</updated>
    
    <content type="html"><![CDATA[<p>最近我在尝试搭建一个利用Git直接部署生产代码的服务器，查了许多资料，了解到需要用到Git Hooks这一特性，就顺便看了一下。</p><h3 id="什么是Git-Hooks？"><a href="#什么是Git-Hooks？" class="headerlink" title="什么是Git Hooks？"></a>什么是Git Hooks？</h3><p>话说，如同其他许多的版本控制系统一样，Git也具有在特定事件发生<strong>之前</strong>或<strong>之后</strong>执行特定脚本代码功能（从概念上类比，就与监听事件、触发器之类的东西类似）。Git Hooks就是那些在Git执行特定事件（如commit、push、receive等）后触发运行的脚本。</p><p>按照Git Hooks脚本所在的位置可以分为两类：</p><ul><li>本地Hooks，触发事件如commit、merge等。</li><li>服务端Hooks，触发事件如receive等。</li></ul><h3 id="Git-Hooks能做什么？"><a href="#Git-Hooks能做什么？" class="headerlink" title="Git Hooks能做什么？"></a>Git Hooks能做什么？</h3><p>Git Hooks是定制化的脚本程序，所以它实现的功能与相应的git动作相关；在实际工作中，Git Hooks还是相对比较万能的。下面仅举几个简单的例子：</p><ul><li>pre-commit: 检查每次的commit message是否有拼写错误，或是否符合某种规范。</li><li>pre-receive: 统一上传到远程库的代码的编码。</li><li>post-receive: 每当有新的提交的时候就通知项目成员（可以使用Email或SMS等方式）。</li><li>post-receive: 把代码推送到生产环境。（这就是我想要做的）</li><li>etc…</li></ul><p>更多的功能可以按照生产环境的需求写出来。</p><h3 id="Git-Hooks是如何工作的？"><a href="#Git-Hooks是如何工作的？" class="headerlink" title="Git Hooks是如何工作的？"></a>Git Hooks是如何工作的？</h3><p>每一个Git repo下都包含有<code>.git/hoooks</code>这个目录（没错，本地和远程都是这样），这里面就是放置Hooks的地方。你可以在这个目录下自由定制Hooks的功能，当触发一些Git行为时，相应地Hooks将被执行。</p><p>这里是一个Git Hooks列表，现在如果觉得不是很明白，不用担心，以后我会继续讲：</p><ul><li>applypatch-msg</li><li>pre-applypatch</li><li>post-applypatch</li><li>pre-commit</li><li>prepare-commit-msg</li><li>commit-msg</li><li>post-commit</li><li>pre-rebase</li><li>post-checkout</li><li>post-merge</li><li>pre-receive</li><li>update</li><li>post-receive</li><li>post-update</li><li>pre-auto-gc</li><li>post-rewrite</li></ul><p><img src="/images/git-hooks-i-1.png" alt><br>图中是我一个本地repo的git hooks示例。</p><h3 id="如何开始使用Git-Hooks？"><a href="#如何开始使用Git-Hooks？" class="headerlink" title="如何开始使用Git Hooks？"></a>如何开始使用Git Hooks？</h3><p>好了，前面啰嗦一大堆，这里才是重点。</p><p>如图中所示的文件，是由本地执行的脚本语言写成的，尽管这些文件默认会是<code>Shell Script</code>，你完全可以给它替换成自己喜欢的<code>Ruby</code>，<code>Python</code>或者<code>Perl</code>。</p><p>举个例子，它是这个样子的：</p><p><img src="/images/git-hooks-i-1.png" alt></p><p>关于这些脚本文件的命名，细心的读者就会发现图中的文件都是上面Git行为列表中列出的名称加上后缀<code>.sample</code>。没错就是这样，把那些文件的后缀去掉，或者以列表中的名字直接命名，就会把该脚本绑定到特定的Git行为上。</p><p>所以说，Git Hooks的正确操作方式是：写脚本。</p><h3 id="Git-Hooks项目介绍"><a href="#Git-Hooks项目介绍" class="headerlink" title="Git Hooks项目介绍"></a>Git Hooks项目介绍</h3><ul><li><a href="https://npmjs.org/package/node-hooks" target="_blank" rel="noopener">node-hooks</a>: 一个命令行下的Git Hooks管理工具</li><li><a href="https://github.com/icefox/git-hooks" target="_blank" rel="noopener">git-hooks</a>: 一个全面的Git Hooks管理工具</li><li><a href="http://search.cpan.org/dist/Git-Hooks/" target="_blank" rel="noopener">Git::Hooks</a>: 一个实现Git Hooks的框架</li><li>etc…</li></ul>]]></content>
    
    <summary type="html">
    
      简单理解Git Hooks
    
    </summary>
    
      <category term="technology" scheme="http://blog.oripd.com/categories/technology/"/>
    
    
      <category term="git" scheme="http://blog.oripd.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>书单 2013</title>
    <link href="http://blog.oripd.com/2013/12/07/booklist/"/>
    <id>http://blog.oripd.com/2013/12/07/booklist/</id>
    <published>2013-12-06T16:00:00.000Z</published>
    <updated>2020-12-17T07:09:33.490Z</updated>
    
    <content type="html"><![CDATA[<p>有朋友找我推荐一些计算机方面的书，我就总结了一下列出一份书单。</p><p>这份书单里提到的书大部分我读过，还有一少部分我没有认真读过而是随便翻看了一下，感觉很不错，会根据我阅读的进度保持跟新。</p><p>本人水平有限，如果读者遇到一些好书，也请多多推荐给我：）</p><h4 id="基础数学-数据结构-算法"><a href="#基础数学-数据结构-算法" class="headerlink" title="基础数学/数据结构/算法"></a>基础数学/数据结构/算法</h4><ul><li><a href="http://book.douban.com/subject/6558200/" target="_blank" rel="noopener">离散数学极其应用（第六版）</a></li><li><a href="http://book.douban.com/subject/10606626/" target="_blank" rel="noopener">组合数学</a></li><li><a href="http://book.douban.com/subject/21323941/" target="_blank" rel="noopener">具体数学（第二版）</a></li><li><a href="http://book.douban.com/subject/6424904/" target="_blank" rel="noopener">大话数据结构</a></li><li><a href="http://book.douban.com/subject/1139426/" target="_blank" rel="noopener">数据结构与算法分析，C语言描述</a></li><li><a href="http://book.douban.com/subject/1239604/" target="_blank" rel="noopener">数据结构与抽象——Java语言版</a></li><li><a href="http://book.douban.com/subject/10742131/" target="_blank" rel="noopener">数据结构与面向对象程序设计（C++版）（第四版）</a></li><li><a href="http://book.douban.com/subject/20432061/" target="_blank" rel="noopener">算法导论（第三版）</a></li><li><a href="http://book.douban.com/subject/19952400/" target="_blank" rel="noopener">算法（第四版）</a></li><li><a href="http://book.douban.com/subject/3227098/" target="_blank" rel="noopener">编程珠玑（第二版）</a></li></ul><h4 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h4><ul><li><a href="http://book.douban.com/subject/1882483/" target="_blank" rel="noopener">C Programming Language</a></li><li><a href="http://book.douban.com/subject/2130190/" target="_blank" rel="noopener">Java编程思想（第四版）</a></li><li><a href="http://book.douban.com/subject/10484692/" target="_blank" rel="noopener">Java并发编程实践</a></li><li><a href="http://book.douban.com/subject/5362860/" target="_blank" rel="noopener">Java解惑</a></li><li><a href="http://book.douban.com/subject/3549421/" target="_blank" rel="noopener">PHP和MySQL Web开发（第四版）</a></li><li><a href="http://book.douban.com/subject/19933548/" target="_blank" rel="noopener">JavaScript编程精解</a></li><li><a href="http://product.dangdang.com/22722790.html" target="_blank" rel="noopener">JavaScript权威指南（第六版）</a></li><li><a href="http://book.douban.com/subject/3590768/" target="_blank" rel="noopener">JavaScript语言精粹</a></li><li><a href="http://book.douban.com/subject/5362856/" target="_blank" rel="noopener">高性能JavaScript</a></li><li><a href="http://book.douban.com/subject/5310233/" target="_blank" rel="noopener">Head First Python</a></li><li><a href="http://book.douban.com/subject/20491078/" target="_blank" rel="noopener">Python Cookbook（第三版）</a></li><li><a href="http://www.amazon.com/Programming-Ruby-1-9-2-0-Programmers/dp/1937785491/" target="_blank" rel="noopener">Programming Ruby 1.9 &amp; 2.0: The Pragmatic Programmers’ Guide</a></li><li><a href="http://railstutorial-china.org/" target="_blank" rel="noopener">Rails Tutorial</a></li><li><a href="http://www.amazon.com/Agile-Development-Rails-Facets-Ruby/dp/1937785564/" target="_blank" rel="noopener">Agile Web Development with Rails 4</a></li><li><a href="http://book.douban.com/subject/7056800/" target="_blank" rel="noopener">Ruby元编程</a></li><li><a href="http://book.douban.com/subject/10789820/" target="_blank" rel="noopener">Node.js开发指南</a></li><li><a href="http://book.douban.com/subject/20515024/" target="_blank" rel="noopener">Node即学即用</a></li><li><a href="http://book.douban.com/subject/25768396/" target="_blank" rel="noopener">深入浅出Node.js</a></li></ul><h4 id="软件工程-实践"><a href="#软件工程-实践" class="headerlink" title="软件工程/实践"></a>软件工程/实践</h4><ul><li><a href="http://product.dangdang.com/1101172606.html" target="_blank" rel="noopener">软件工程：实践者的研究方法（第七版）</a></li><li><a href="http://book.douban.com/subject/4908230/" target="_blank" rel="noopener">人月神话</a></li><li><a href="http://book.douban.com/subject/11874743/" target="_blank" rel="noopener">设计原本</a></li><li><a href="http://book.douban.com/subject/4210602/" target="_blank" rel="noopener">大道至简</a></li><li><a href="http://book.douban.com/subject/1173548/" target="_blank" rel="noopener">程序设计实践</a></li><li><a href="https://book.douban.com/subject/26577755/" target="_blank" rel="noopener">构建之法：现代软件工程（第二版）</a></li><li><a href="http://book.douban.com/subject/1052241/" target="_blank" rel="noopener">设计模式</a></li><li><a href="http://book.douban.com/subject/1214074/" target="_blank" rel="noopener">Java与模式</a></li></ul><h4 id="多范式-编程思想"><a href="#多范式-编程思想" class="headerlink" title="多范式/编程思想"></a>多范式/编程思想</h4><ul><li><a href="http://book.douban.com/subject/1148282/" target="_blank" rel="noopener">计算机程序的构造和解释</a></li><li><a href="http://book.douban.com/subject/1140942/" target="_blank" rel="noopener">How to Design Program</a></li><li><a href="https://book.douban.com/subject/10555435/" target="_blank" rel="noopener">七周七语言：理解多种编程模型</a></li></ul><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li><a href="http://book.douban.com/subject/3852290/" target="_blank" rel="noopener">现代操作系统（第三版）</a></li><li><a href="http://www.amazon.cn/%E5%9B%BD%E5%A4%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%95%99%E6%9D%90%E7%B3%BB%E5%88%97%E2%80%A2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%B2%BE%E9%AB%93%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E5%A8%81%E5%BB%89%E2%80%A2%E6%96%AF%E6%89%98%E6%9E%97%E6%96%AF/dp/B009P8FGSY" target="_blank" rel="noopener">操作系统——精髓与设计原理（第七版）</a></li><li><a href="http://book.douban.com/subject/11530329/" target="_blank" rel="noopener">30天自制操作系统</a></li></ul><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><ul><li><a href="https://book.douban.com/subject/26176870/" target="_blank" rel="noopener">计算机网络：自顶向下方法（第六版）</a></li><li><a href="http://book.douban.com/subject/10510747/" target="_blank" rel="noopener">计算机网络（第五版）</a></li><li><a href="http://book.douban.com/subject/10746113/" target="_blank" rel="noopener">HTTP权威指南</a></li></ul><h4 id="Linux-UNIX"><a href="#Linux-UNIX" class="headerlink" title="Linux/UNIX"></a>Linux/UNIX</h4><ul><li><a href="http://book.douban.com/subject/4889838/" target="_blank" rel="noopener">鸟哥的私房菜：基础学习篇（第三版）</a></li><li><a href="http://book.douban.com/subject/10794788/" target="_blank" rel="noopener">鸟哥的私房菜：服务器架设篇（第三版）</a></li><li><a href="http://book.douban.com/subject/3229243/" target="_blank" rel="noopener">Linux内核完全剖析</a></li><li><a href="http://book.douban.com/subject/1231236/" target="_blank" rel="noopener">Linux内核完全注释</a></li><li><a href="http://book.douban.com/subject/6097773/" target="_blank" rel="noopener">Linux内核设计与实现</a></li><li><a href="http://book.douban.com/subject/2287506/" target="_blank" rel="noopener">深入理解Linux内核</a></li><li><a href="http://book.douban.com/subject/1788421/" target="_blank" rel="noopener">UNIX环境高级编程（第二版）</a></li><li><a href="http://book.douban.com/subject/1500149/" target="_blank" rel="noopener">UNIX网络编程：第一卷</a></li><li><a href="http://book.douban.com/subject/4886882/" target="_blank" rel="noopener">UNIX网络编程：第二卷</a></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><a href="http://book.douban.com/subject/7564417/" target="_blank" rel="noopener">Linux/UNIX设计思想</a></li><li><a href="http://book.douban.com/subject/1467587/" target="_blank" rel="noopener">UNIX编程艺术</a></li><li><a href="http://book.douban.com/subject/3924175/" target="_blank" rel="noopener">构建高性能Web站点</a></li><li><a href="http://book.douban.com/subject/6758780/" target="_blank" rel="noopener">大规模Web服务开发技术</a></li><li><a href="http://book.douban.com/subject/10432364/" target="_blank" rel="noopener">奇思妙想：15位计算机天才极其重大发现</a></li><li><a href="http://book.douban.com/subject/6021440/" target="_blank" rel="noopener">黑客与画家</a></li><li><a href="http://book.douban.com/subject/4719230/" target="_blank" rel="noopener">编程之魂：与27位编程语言创始人对话</a></li><li><a href="http://book.douban.com/subject/10750155/" target="_blank" rel="noopener">数学之美</a></li><li><a href="http://book.douban.com/subject/10779597/" target="_blank" rel="noopener">思考的乐趣：Matrix67数学笔记</a></li><li><a href="http://book.douban.com/subject/24738302/" target="_blank" rel="noopener">浪潮之巅</a></li><li><a href="http://book.douban.com/subject/1827702/" target="_blank" rel="noopener">DON’T MAKE ME THINK 点石成金</a></li><li><a href="http://book.douban.com/subject/5375620/" target="_blank" rel="noopener">失控</a></li><li><a href="http://book.douban.com/subject/6965746/" target="_blank" rel="noopener">科技想要什么</a></li><li><a href="http://book.douban.com/subject/6860890/" target="_blank" rel="noopener">黑客：计算机革命的英雄</a></li><li><a href="http://book.douban.com/subject/6709809/" target="_blank" rel="noopener">暗时间</a></li><li><a href="http://book.douban.com/subject/1291204/" target="_blank" rel="noopener">哥德尔、艾舍尔、巴赫: 集异璧之大成</a></li></ul><p>就先写这么多，欢迎大家补充。</p>]]></content>
    
    <summary type="html">
    
      自己收藏的书单，不定期更新
    
    </summary>
    
      <category term="thinking" scheme="http://blog.oripd.com/categories/thinking/"/>
    
    
      <category term="book" scheme="http://blog.oripd.com/tags/book/"/>
    
  </entry>
  
</feed>
